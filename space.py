"""
Created by Diego Rubio Canales in ene 2025
Universidad Carlos III de Madrid
"""
from UHD.button import Button
from particle import Particle
import pyxel

class Space:
    def __init__(self, width: int, height: int, bodies: list[Particle]):
        self.__width = width
        self.__height = height

        # Particle list
        self.bodies = bodies
        self.button = Button("Prueba", 10, 10, 200, 10, "HOLA COMO ESTAS")


    def update_space(self):
        """Main loop during simulation"""
        self._restar_body_acceleration()
        self._magnetic_field_acceleration()
        self._electric_field_acceleration()
        self._actualize_particles(1)

    def draw_space(self):
        # Limpia la pantalla con el color 0 (negro)
        pyxel.cls(0)
        self._draw_bodies()
        self._draw_vector_a()
        self.button.draw()

    def _draw_bodies(self):
        for body in self.bodies:
            pyxel.circ(int(body.pos.i), int(body.pos.j), 2, 200)

    def _draw_vector_a(self):
        for body in self.bodies:
            x_0 = body.pos.i
            y_0 = body.pos.j
            x_f = x_0 + body.a.i * 1000
            y_f = y_0 + body.a.j * 1000
            pyxel.line(x_0, y_0, x_f, y_f, 1)

    def _restar_body_acceleration(self):
        for body in self.bodies:
            body.restart_acceleration()

    def _actualize_particles(self, dt: float):
        for particle in self.bodies:
            particle.actualize_velocity(dt)
            particle.actualize_position(dt)

    def _magnetic_field_acceleration(self):
        """Method that calculates de acceleration due to all the masses in a space"""

        for particle in self.bodies:
            # List of each body without the particle
            interact_with = self.bodies.copy()
            interact_with.remove(particle)
            # Calculates de current particle acceleration due other
            # particles using the method <g_field_generated>
            for other_particle in interact_with:

                # G-Field generated by "other_particle" at particle position
                g = other_particle.g_field_generated(
                    particle.pos.i, particle.pos.j, particle.pos.k)

                # Sum the current acceleration of the particle
                particle.a = particle.a + g

    def _electric_field_acceleration(self):
        """Method that calculates de acceleration due to all the charges in a
        space"""

        for particle in self.bodies:
            # List of each body without the particle
            interact_with = self.bodies.copy()
            interact_with.remove(particle)
            # Calculates de current particle acceleration due other
            # particles using the method <e_field_generated>
            for other_particle in interact_with:
                # E-Field generated by "other_particle" at particle position
                E = other_particle.e_field_generated(
                    particle.pos.i, particle.pos.j, particle.pos.k)

                # Sum the current acceleration of the particle with the field
                particle.a = particle.a + E * (particle.q / particle.m)